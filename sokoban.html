<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>æ¨ç®±å­</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        background: linear-gradient(135deg, #8b7355 0%, #a0826d 100%);
        font-family: 'Arial', sans-serif;
        padding: 20px;
      }

      .game-container {
        display: flex;
        background: #fff;
        border-radius: 10px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        position: relative;
        overflow: hidden;
      }

      .sidebar {
        width: 250px;
        padding: 30px;
        background: linear-gradient(180deg, #f5f5f5 0%, #e8e8e8 100%);
        display: flex;
        flex-direction: column;
        border-right: 2px solid #ddd;
      }

      h1 {
        color: #333;
        margin-bottom: 20px;
        font-size: 24px;
      }

      .controls {
        color: #666;
        margin-bottom: 30px;
        font-size: 14px;
        line-height: 1.6;
      }

      .score-board {
        margin-top: auto;
        font-size: 16px;
        font-weight: bold;
      }

      .score-item {
        color: #333;
        margin-bottom: 10px;
      }

      .game-area {
        flex: 1;
        padding: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      canvas {
        border: 3px solid #333;
        border-radius: 5px;
        display: block;
        background: #d4a574;
      }

      .level-complete {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 40px 60px;
        border-radius: 15px;
        font-size: 24px;
        text-align: center;
        display: none;
        z-index: 1000;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        border: 3px solid #4caf50;
      }

      .level-complete button {
        margin-top: 20px;
        padding: 10px 30px;
        font-size: 18px;
        background: #4caf50;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        transition: background 0.3s;
      }

      .level-complete button:hover {
        background: #45a049;
      }
    </style>
  </head>
  <body>
    <div class="game-container">
      <div class="sidebar">
        <h1>ğŸ“¦ æ¨ç®±å­</h1>
        <div class="controls">
          <strong>æ“ä½œè¯´æ˜ï¼š</strong><br />
          æ–¹å‘é”® â†‘ â†“ â† â†’ ç§»åŠ¨<br />
          R é‡ç½®å…³å¡
        </div>
        <div class="score-board">
          <div class="score-item">
            å…³å¡: <span id="level">1</span> / <span id="totalLevels">5</span>
          </div>
          <div class="score-item">æ­¥æ•°: <span id="moves">0</span></div>
          <div class="score-item">ç®±å­: <span id="boxesLeft">0</span></div>
        </div>
      </div>
      <div class="game-area">
        <canvas id="gameCanvas" width="700" height="700"></canvas>
      </div>
    </div>
    <div id="levelComplete" class="level-complete">
      <div>ğŸ‰ å…³å¡å®Œæˆï¼</div>
      <div style="font-size: 18px; margin-top: 10px">æ­¥æ•°: <span id="completeMoves">0</span></div>
      <button onclick="nextLevel()">ä¸‹ä¸€å…³</button>
    </div>

    <script>
      const canvas = document.getElementById('gameCanvas');
      canvas.width = 700;
      canvas.height = 700;
      const ctx = canvas.getContext('2d');
      const levelElement = document.getElementById('level');
      const totalLevelsElement = document.getElementById('totalLevels');
      const movesElement = document.getElementById('moves');
      const boxesLeftElement = document.getElementById('boxesLeft');
      const levelCompleteElement = document.getElementById('levelComplete');
      const completeMovesElement = document.getElementById('completeMoves');

      const tileSize = 40;
      const cols = 15;
      const rows = 15;

      // æ¸¸æˆå…ƒç´ ç±»å‹
      const WALL = 1;
      const BOX = 2;
      const TARGET = 3;
      const PLAYER = 4;
      const BOX_ON_TARGET = 5;
      const FLOOR = 0;

      let currentLevel = 1;
      const totalLevels = 5;
      let moves = 0;
      let levelData = [];
      let playerPos = { x: 0, y: 0 };
      let initialLevelData = [];
      let targetPositions = []; // å­˜å‚¨æ‰€æœ‰ç›®æ ‡ä½ç½®ï¼Œç¡®ä¿åœˆåœˆå§‹ç»ˆæ˜¾ç¤º

      // å…³å¡æ•°æ®
      const levels = [
        // å…³å¡1
        [
          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        ],
        // å…³å¡2
        [
          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        ],
        // å…³å¡3
        [
          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        ],
        // å…³å¡4
        [
          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        ],
        // å…³å¡5
        [
          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        ],
      ];

      // éŸ³æ•ˆç³»ç»Ÿ
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      let audioEnabled = false;

      function enableAudio() {
        if (!audioEnabled) {
          audioContext.resume();
          audioEnabled = true;
        }
      }

      function playSound(frequency, duration, type = 'sine', volume = 0.2) {
        if (!audioEnabled) return;
        try {
          const oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();

          oscillator.connect(gainNode);
          gainNode.connect(audioContext.destination);

          oscillator.frequency.value = frequency;
          oscillator.type = type;
          gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);

          oscillator.start(audioContext.currentTime);
          oscillator.stop(audioContext.currentTime + duration);
        } catch (e) {}
      }

      function playMoveSound() {
        playSound(200, 0.1, 'sine', 0.15);
      }

      function playPushSound() {
        playSound(150, 0.15, 'square', 0.2);
      }

      function playCompleteSound() {
        playSound(523, 0.2, 'sine', 0.3);
        setTimeout(() => playSound(659, 0.2, 'sine', 0.3), 150);
        setTimeout(() => playSound(784, 0.3, 'sine', 0.3), 300);
      }

      // åˆå§‹åŒ–å…³å¡
      function initLevel(levelNum) {
        // ç®€åŒ–ç‰ˆï¼šåˆ›å»ºç®€å•å…³å¡
        levelData = [];
        for (let r = 0; r < rows; r++) {
          levelData[r] = [];
          for (let c = 0; c < cols; c++) {
            if (r === 0 || r === rows - 1 || c === 0 || c === cols - 1) {
              levelData[r][c] = WALL;
            } else {
              levelData[r][c] = FLOOR;
            }
          }
        }

        // æ·»åŠ ç©å®¶
        playerPos = { x: 2, y: 2 };
        levelData[playerPos.y][playerPos.x] = PLAYER;

        // æ·»åŠ ç®±å­å’Œç›®æ ‡ç‚¹
        const boxCount = levelNum + 1;
        targetPositions = []; // é‡ç½®ç›®æ ‡ä½ç½®æ•°ç»„
        for (let i = 0; i < boxCount; i++) {
          const bx = 3 + (i % 3) * 2;
          const by = 3 + Math.floor(i / 3) * 2;
          levelData[by][bx] = BOX;
          const targetX = cols - 3 - (i % 3) * 2;
          const targetY = rows - 3 - Math.floor(i / 3) * 2;
          targetPositions.push({ x: targetX, y: targetY }); // ä¿å­˜ç›®æ ‡ä½ç½®
          levelData[targetY][targetX] = TARGET;
        }

        initialLevelData = JSON.parse(JSON.stringify(levelData));
        moves = 0;
        movesElement.textContent = moves;
        updateBoxesLeft();
      }

      // æ›´æ–°å‰©ä½™ç®±å­æ•°
      function updateBoxesLeft() {
        let boxes = 0;
        let targets = 0;
        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            if (levelData[r][c] === BOX) boxes++;
            if (levelData[r][c] === TARGET) targets++;
          }
        }
        boxesLeftElement.textContent = boxes + ' / ' + targets;
      }

      // ç§»åŠ¨ç©å®¶
      function movePlayer(dx, dy) {
        const newX = playerPos.x + dx;
        const newY = playerPos.y + dy;

        if (newX < 0 || newX >= cols || newY < 0 || newY >= rows) return;

        const currentTile = levelData[newY][newX];

        if (currentTile === WALL) return;

        if (currentTile === BOX || currentTile === BOX_ON_TARGET) {
          const boxX = newX + dx;
          const boxY = newY + dy;

          if (boxX < 0 || boxX >= cols || boxY < 0 || boxY >= rows) return;

          const boxTile = levelData[boxY][boxX];
          if (boxTile === WALL || boxTile === BOX || boxTile === BOX_ON_TARGET) return;

          // ç§»åŠ¨ç®±å­
          if (boxTile === TARGET) {
            levelData[boxY][boxX] = BOX_ON_TARGET;
          } else {
            levelData[boxY][boxX] = BOX;
          }

          if (currentTile === BOX_ON_TARGET) {
            levelData[newY][newX] = TARGET;
          } else {
            levelData[newY][newX] = FLOOR;
          }

          playPushSound();
        } else {
          playMoveSound();
        }

        // ç§»åŠ¨ç©å®¶
        // æ£€æŸ¥ç©å®¶å½“å‰ä½ç½®æ˜¯å¦æ˜¯ç›®æ ‡ä½ç½®
        const isCurrentPosTarget = targetPositions.some(
          (t) => t.x === playerPos.x && t.y === playerPos.y,
        );
        if (levelData[playerPos.y][playerPos.x] === PLAYER) {
          // å¦‚æœå½“å‰ä½ç½®æ˜¯ç›®æ ‡ä½ç½®ï¼Œæ¢å¤ä¸º TARGETï¼Œå¦åˆ™æ¢å¤ä¸º FLOOR
          levelData[playerPos.y][playerPos.x] = isCurrentPosTarget ? TARGET : FLOOR;
        }
        playerPos.x = newX;
        playerPos.y = newY;
        // æ£€æŸ¥æ–°ä½ç½®æ˜¯å¦æ˜¯ç›®æ ‡ä½ç½®
        const isNewPosTarget = targetPositions.some((t) => t.x === newX && t.y === newY);
        // è®¾ç½®æ–°ä½ç½®ï¼šå¦‚æœæ˜¯ç›®æ ‡ä½ç½®ï¼Œä¿æŒ TARGETï¼ˆç»˜åˆ¶æ—¶ä¼šå•ç‹¬ç»˜åˆ¶åœˆåœˆï¼‰ï¼Œå¦åˆ™è®¾ç½®ä¸º FLOOR
        if (!isNewPosTarget) {
          levelData[playerPos.y][playerPos.x] = PLAYER;
        } else {
          // æ–°ä½ç½®æ˜¯ç›®æ ‡ä½ç½®ï¼Œè®¾ç½®ä¸º PLAYERï¼ˆç»˜åˆ¶æ—¶ä¼šå•ç‹¬ç»˜åˆ¶åœˆåœˆï¼‰
          levelData[playerPos.y][playerPos.x] = PLAYER;
        }

        moves++;
        movesElement.textContent = moves;
        updateBoxesLeft();

        // æ£€æŸ¥æ˜¯å¦å®Œæˆ
        checkLevelComplete();
      }

      // æ£€æŸ¥å…³å¡å®Œæˆ
      function checkLevelComplete() {
        // æ£€æŸ¥æ¯ä¸ªç›®æ ‡ä½ç½®ä¸Šæ˜¯å¦éƒ½æœ‰ç®±å­
        let allTargetsHaveBoxes = true;

        for (let target of targetPositions) {
          const tile = levelData[target.y][target.x];
          // å¦‚æœç›®æ ‡ä½ç½®ä¸Šçš„ä¸æ˜¯ BOX_ON_TARGETï¼Œè¯´æ˜æ²¡æœ‰ç®±å­åœ¨ä¸Šé¢
          if (tile !== BOX_ON_TARGET) {
            allTargetsHaveBoxes = false;
            break;
          }
        }

        // å¦‚æœæ‰€æœ‰ç›®æ ‡ä½ç½®éƒ½æœ‰ç®±å­ï¼Œä¸”æ²¡æœ‰ä¸åœ¨ç›®æ ‡ä½ç½®çš„ç®±å­
        if (allTargetsHaveBoxes && targetPositions.length > 0) {
          // å†æ¬¡ç¡®è®¤æ²¡æœ‰ä¸åœ¨ç›®æ ‡ä½ç½®çš„ç®±å­
          let boxesNotOnTargets = 0;
          for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
              if (levelData[r][c] === BOX) {
                boxesNotOnTargets++;
              }
            }
          }

          if (boxesNotOnTargets === 0) {
            playCompleteSound();
            completeMovesElement.textContent = moves;
            levelCompleteElement.style.display = 'block';
          }
        }
      }

      // ä¸‹ä¸€å…³
      function nextLevel() {
        if (currentLevel < totalLevels) {
          currentLevel++;
          levelElement.textContent = currentLevel;
          levelCompleteElement.style.display = 'none';
          initLevel(currentLevel);
          drawGame();
        } else {
          alert('ğŸ‰ æ­å–œï¼ä½ å®Œæˆäº†æ‰€æœ‰å…³å¡ï¼');
          currentLevel = 1;
          levelElement.textContent = currentLevel;
          levelCompleteElement.style.display = 'none';
          initLevel(currentLevel);
          drawGame();
        }
      }

      // é‡ç½®å…³å¡
      function resetLevel() {
        levelData = JSON.parse(JSON.stringify(initialLevelData));
        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            if (levelData[r][c] === PLAYER) {
              playerPos = { x: c, y: r };
            }
          }
        }
        moves = 0;
        movesElement.textContent = moves;
        updateBoxesLeft();
        drawGame();
      }

      // ç»˜åˆ¶æ¸¸æˆ
      function drawGame() {
        ctx.fillStyle = '#D4A574';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // å…ˆç»˜åˆ¶æ‰€æœ‰åŸºç¡€å…ƒç´ 
        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            const x = c * tileSize;
            const y = r * tileSize;
            const tile = levelData[r][c];

            if (tile === WALL) {
              ctx.fillStyle = '#8B7355';
              ctx.fillRect(x, y, tileSize, tileSize);
              ctx.strokeStyle = '#654321';
              ctx.lineWidth = 2;
              ctx.strokeRect(x, y, tileSize, tileSize);
            } else if (tile === TARGET) {
              // ç©ºçš„ç›®æ ‡ä½ç½®ï¼Œåªç»˜åˆ¶åœ°æ¿ï¼Œåœˆåœˆä¼šåœ¨åé¢ç»Ÿä¸€ç»˜åˆ¶
              ctx.fillStyle = '#D4A574';
              ctx.fillRect(x, y, tileSize, tileSize);
            } else if (tile === BOX) {
              ctx.fillStyle = '#D4A574';
              ctx.fillRect(x, y, tileSize, tileSize);
              ctx.fillStyle = '#8B4513';
              ctx.fillRect(x + 5, y + 5, tileSize - 10, tileSize - 10);
              ctx.strokeStyle = '#654321';
              ctx.lineWidth = 2;
              ctx.strokeRect(x + 5, y + 5, tileSize - 10, tileSize - 10);
            } else if (tile === BOX_ON_TARGET) {
              // ç®±å­åœ¨ç›®æ ‡ä½ç½®ä¸Šï¼Œå…ˆç»˜åˆ¶åœ°æ¿å’Œç®±å­
              ctx.fillStyle = '#D4A574';
              ctx.fillRect(x, y, tileSize, tileSize);
              ctx.fillStyle = '#8B4513';
              ctx.fillRect(x + 5, y + 5, tileSize - 10, tileSize - 10);
              ctx.strokeStyle = '#654321';
              ctx.lineWidth = 2;
              ctx.strokeRect(x + 5, y + 5, tileSize - 10, tileSize - 10);
            } else if (tile === PLAYER) {
              ctx.fillStyle = '#D4A574';
              ctx.fillRect(x, y, tileSize, tileSize);
              ctx.fillStyle = '#4ECDC4';
              ctx.beginPath();
              ctx.arc(x + tileSize / 2, y + tileSize / 2, tileSize / 3, 0, Math.PI * 2);
              ctx.fill();
              ctx.fillStyle = '#000';
              ctx.fillRect(x + tileSize / 2 - 3, y + tileSize / 2 - 5, 6, 6);
            }
          }
        }

        // æœ€åç»˜åˆ¶æ‰€æœ‰ç›®æ ‡ä½ç½®çš„åœˆåœˆï¼ˆç¡®ä¿å§‹ç»ˆæ˜¾ç¤ºï¼‰
        ctx.strokeStyle = '#4CAF50';
        ctx.lineWidth = 3;
        for (let target of targetPositions) {
          const x = target.x * tileSize;
          const y = target.y * tileSize;
          ctx.beginPath();
          ctx.arc(x + tileSize / 2, y + tileSize / 2, tileSize / 4, 0, Math.PI * 2);
          ctx.stroke();
        }
      }

      // é”®ç›˜æ§åˆ¶
      document.addEventListener('keydown', (e) => {
        enableAudio();

        if (e.code === 'ArrowUp') {
          movePlayer(0, -1);
          drawGame();
        } else if (e.code === 'ArrowDown') {
          movePlayer(0, 1);
          drawGame();
        } else if (e.code === 'ArrowLeft') {
          movePlayer(-1, 0);
          drawGame();
        } else if (e.code === 'ArrowRight') {
          movePlayer(1, 0);
          drawGame();
        } else if (e.code === 'KeyR' || e.code === 'Keyr') {
          resetLevel();
        }
      });

      document.addEventListener('click', enableAudio, { once: true });

      // åˆå§‹åŒ–
      totalLevelsElement.textContent = totalLevels;
      initLevel(currentLevel);
      drawGame();
    </script>
  </body>
</html>
